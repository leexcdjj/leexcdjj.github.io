
[{"content":"","date":"22 八月 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"22 八月 2025","externalUrl":null,"permalink":"/article/","section":"Articles","summary":"","title":"Articles","type":"article"},{"content":"","date":"22 八月 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"22 八月 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"22 八月 2025","externalUrl":null,"permalink":"/tags/zalo/","section":"Tags","summary":"","title":"ZALO","type":"tags"},{"content":" 前言 # 在越南，类似国内WeChat的机器人应用尚未普及，因此作者突发奇想开发一个简单的Zalo机器人。本指南详细介绍了如何创建一个基础的Zalo机器人，具备以下两个功能：\n获取所有好友列表 向指定好友发送消息 本文将介绍如何通过Node.js服务器和C#客户端实现上述功能，包括代码实现、接口调用以及最终效果演示。\n声明：本文仅用于教育和研究目的。逆向工程可能违反Zalo的服务条款，请勿用于任何违规行为。\n最终效果 # 程序\n程序成功向指定用户（显示名称为“Thu Thuỷ”）发送了消息“我是不是你最疼爱的人”。效果截图如下：\n项目概述 # 本项目由以下两部分组成：\nNode.js服务器：提供API接口，供C#客户端调用。 C#客户端：通过调用Node.js服务器的API实现好友获取和消息发送功能。 API 接口说明 # 服务器提供了两个核心接口：\nGET /api/getAllFriends：获取所有好友列表。 POST /api/sendMessage：向指定用户发送消息。 接口截图如下：\nC# 项目实现 # 1. ApiClient 类 # ApiClient 类负责与Node.js服务器的HTTP通信，支持GET、POST、PUT和DELETE请求。\nusing System.Text; using System.Text.Json; using System.Web; using System.Net.Http.Headers; namespace ZaloBot.Console; public class ApiClient : IDisposable { private readonly HttpClient _httpClient; private readonly string _baseUrl = \u0026#34;http://localhost:3000/\u0026#34;; private readonly JsonSerializerOptions _jsonOptions; private bool _disposed; public ApiClient() { _httpClient = new HttpClient(); _httpClient.BaseAddress = new Uri(_baseUrl); _httpClient.DefaultRequestHeaders.Accept.Clear(); _httpClient.DefaultRequestHeaders.Accept.Add( new MediaTypeWithQualityHeaderValue(\u0026#34;application/json\u0026#34;)); _jsonOptions = new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase, WriteIndented = true }; } // POST 请求方法：请求参数为 JSON Body public async Task\u0026lt;TResponse\u0026gt; PostAsync\u0026lt;TRequest, TResponse\u0026gt;(string endpoint, TRequest requestData) { if (string.IsNullOrEmpty(endpoint)) throw new ArgumentNullException(nameof(endpoint)); try { string jsonRequest = JsonSerializer.Serialize(requestData, _jsonOptions); var content = new StringContent(jsonRequest, Encoding.UTF8, \u0026#34;application/json\u0026#34;); HttpResponseMessage response = await _httpClient.PostAsync(endpoint, content); response.EnsureSuccessStatusCode(); string jsonResponse = await response.Content.ReadAsStringAsync(); return JsonSerializer.Deserialize\u0026lt;TResponse\u0026gt;(jsonResponse, _jsonOptions)!; } catch (HttpRequestException ex) { throw new Exception($\u0026#34;POST request to {_baseUrl}{endpoint} failed: {ex.Message}\u0026#34;, ex); } } // GET 请求方法：请求参数序列化为 JSON 后作为查询参数 public async Task\u0026lt;TResponse\u0026gt; GetAsync\u0026lt;TResponse\u0026gt;(string endpoint, object? requestData = null) { if (string.IsNullOrEmpty(endpoint)) throw new ArgumentNullException(nameof(endpoint)); try { string fullEndpoint = endpoint; if (requestData != null) { string jsonRequest = JsonSerializer.Serialize(requestData, _jsonOptions); string encodedJson = HttpUtility.UrlEncode(jsonRequest); fullEndpoint = $\u0026#34;{endpoint}?data={encodedJson}\u0026#34;; } HttpResponseMessage response = await _httpClient.GetAsync(fullEndpoint); response.EnsureSuccessStatusCode(); string jsonResponse = await response.Content.ReadAsStringAsync(); return JsonSerializer.Deserialize\u0026lt;TResponse\u0026gt;(jsonResponse, _jsonOptions)!; } catch (HttpRequestException ex) { throw new Exception($\u0026#34;GET request to {_baseUrl}{endpoint} failed: {ex.Message}\u0026#34;, ex); } } // PUT 请求方法：请求参数为 JSON Body public async Task\u0026lt;TResponse\u0026gt; PutAsync\u0026lt;TRequest, TResponse\u0026gt;(string endpoint, TRequest requestData) { if (string.IsNullOrEmpty(endpoint)) throw new ArgumentNullException(nameof(endpoint)); try { string jsonRequest = JsonSerializer.Serialize(requestData, _jsonOptions); var content = new StringContent(jsonRequest, Encoding.UTF8, \u0026#34;application/json\u0026#34;); HttpResponseMessage response = await _httpClient.PutAsync(endpoint, content); response.EnsureSuccessStatusCode(); string jsonResponse = await response.Content.ReadAsStringAsync(); return JsonSerializer.Deserialize\u0026lt;TResponse\u0026gt;(jsonResponse, _jsonOptions)!; } catch (HttpRequestException ex) { throw new Exception($\u0026#34;PUT request to {_baseUrl}{endpoint} failed: {ex.Message}\u0026#34;, ex); } } // DELETE 请求方法：请求参数序列化为 JSON 后作为查询参数 public async Task\u0026lt;TResponse\u0026gt; DeleteAsync\u0026lt;TResponse\u0026gt;(string endpoint, object? requestData = null) { if (string.IsNullOrEmpty(endpoint)) throw new ArgumentNullException(nameof(endpoint)); try { string fullEndpoint = endpoint; if (requestData != null) { string jsonRequest = JsonSerializer.Serialize(requestData, _jsonOptions); string encodedJson = HttpUtility.UrlEncode(jsonRequest); fullEndpoint = $\u0026#34;{endpoint}?data={encodedJson}\u0026#34;; } HttpResponseMessage response = await _httpClient.DeleteAsync(fullEndpoint); response.EnsureSuccessStatusCode(); string jsonResponse = await response.Content.ReadAsStringAsync(); return JsonSerializer.Deserialize\u0026lt;TResponse\u0026gt;(jsonResponse, _jsonOptions)!; } catch (HttpRequestException ex) { throw new Exception($\u0026#34;DELETE request to {_baseUrl}{endpoint} failed: {ex.Message}\u0026#34;, ex); } } // 释放资源 public void Dispose() { if (!_disposed) { _httpClient?.Dispose(); _disposed = true; } } } 2. User 模型 # User 类定义了Zalo用户的数据结构，包含用户ID、用户名、头像等信息。\nnamespace ZaloBot.Console.Models; public class User { /// \u0026lt;summary\u0026gt; /// 用户ID /// \u0026lt;/summary\u0026gt; public string UserId { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// 用户名 /// \u0026lt;/summary\u0026gt; public string Username { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// 显示名称 /// \u0026lt;/summary\u0026gt; public string DisplayName { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// Zalo名称 /// \u0026lt;/summary\u0026gt; public string ZaloName { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// 头像URL /// \u0026lt;/summary\u0026gt; public string Avatar { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// 背景头像URL /// \u0026lt;/summary\u0026gt; public string Bgavatar { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// 封面URL /// \u0026lt;/summary\u0026gt; public string Cover { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// 性别（数字表示） /// \u0026lt;/summary\u0026gt; public int Gender { get; set; } /// \u0026lt;summary\u0026gt; /// 出生日期（时间戳） /// \u0026lt;/summary\u0026gt; public long Dob { get; set; } /// \u0026lt;summary\u0026gt; /// 出生日期（字符串格式） /// \u0026lt;/summary\u0026gt; public string Sdob { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// 状态 /// \u0026lt;/summary\u0026gt; public string Status { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// 电话号码 /// \u0026lt;/summary\u0026gt; public string PhoneNumber { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// 是否为朋友（数字表示，0或1） /// \u0026lt;/summary\u0026gt; public int IsFr { get; set; } /// \u0026lt;summary\u0026gt; /// 是否被屏蔽（数字表示，0或1） /// \u0026lt;/summary\u0026gt; public int IsBlocked { get; set; } /// \u0026lt;summary\u0026gt; /// 最后活动时间（时间戳） /// \u0026lt;/summary\u0026gt; public long LastActionTime { get; set; } /// \u0026lt;summary\u0026gt; /// 最后更新时间（时间戳） /// \u0026lt;/summary\u0026gt; public long LastUpdateTime { get; set; } /// \u0026lt;summary\u0026gt; /// 是否活跃（数字表示，0或1） /// \u0026lt;/summary\u0026gt; public int IsActive { get; set; } /// \u0026lt;summary\u0026gt; /// 密钥（数字） /// \u0026lt;/summary\u0026gt; public int Key { get; set; } /// \u0026lt;summary\u0026gt; /// 类型（数字表示） /// \u0026lt;/summary\u0026gt; public int Type { get; set; } /// \u0026lt;summary\u0026gt; /// 是否在PC端活跃（数字表示，0或1） /// \u0026lt;/summary\u0026gt; public int IsActivePC { get; set; } /// \u0026lt;summary\u0026gt; /// 是否在Web端活跃（数字表示，0或1） /// \u0026lt;/summary\u0026gt; public int IsActiveWeb { get; set; } /// \u0026lt;summary\u0026gt; /// 是否有效（数字表示，0或1） /// \u0026lt;/summary\u0026gt; public int IsValid { get; set; } /// \u0026lt;summary\u0026gt; /// 用户密钥 /// \u0026lt;/summary\u0026gt; public string UserKey { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// 账户状态（数字表示） /// \u0026lt;/summary\u0026gt; public int AccountStatus { get; set; } /// \u0026lt;summary\u0026gt; /// OA信息（任意类型） /// \u0026lt;/summary\u0026gt; public object? OaInfo { get; set; } /// \u0026lt;summary\u0026gt; /// 用户模式（数字表示） /// \u0026lt;/summary\u0026gt; public int UserMode { get; set; } /// \u0026lt;summary\u0026gt; /// 全局ID /// \u0026lt;/summary\u0026gt; public string GlobalId { get; set; } = string.Empty; /// \u0026lt;summary\u0026gt; /// 业务包（任意类型） /// \u0026lt;/summary\u0026gt; public object? BizPkg { get; set; } /// \u0026lt;summary\u0026gt; /// 标签（任意类型） /// \u0026lt;/summary\u0026gt; public object? Label { get; set; } /// \u0026lt;summary\u0026gt; /// 包ID（数字） /// \u0026lt;/summary\u0026gt; public int PkgId { get; set; } /// \u0026lt;summary\u0026gt; /// 创建时间（时间戳） /// \u0026lt;/summary\u0026gt; public long CreatedTs { get; set; } /// \u0026lt;summary\u0026gt; /// OA状态（任意类型） /// \u0026lt;/summary\u0026gt; public object? OaStatus { get; set; } } 3. JsonResponse 模型 # JsonResponse 类用于解析API返回的JSON数据，包含状态码、消息和数据列表。\nnamespace ZaloBot.Console; public class JsonResponse\u0026lt;T\u0026gt; where T : class { public int Code { get; set; } public string Message { get; set; } = string.Empty; public List\u0026lt;T\u0026gt; Data { get; set; } = new List\u0026lt;T\u0026gt;(); } public class JsonResponse { public int Code { get; set; } public string Message { get; set; } = string.Empty; } 4. 主程序调用逻辑 # 以下代码展示了如何通过ApiClient调用API，获取好友列表并向特定用户发送消息。\nnamespace ZaloBot.Console; class Program { static async Task Main(string[] args) { using ApiClient client = new ApiClient(); // 获取所有好友 var allUsers = await client.GetAsync\u0026lt;JsonResponse\u0026lt;User\u0026gt;\u0026gt;(\u0026#34;api/getAllFriends\u0026#34;); // 筛选特定用户 var user = allUsers.Data.Where(a =\u0026gt; a.DisplayName == \u0026#34;Thu Thuỷ\u0026#34;); // 向筛选出的用户发送消息 foreach (var u in user) { await client.PostAsync\u0026lt;object, JsonResponse\u0026gt;(\u0026#34;api/sendMessage\u0026#34;, new { userID = u.UserId, message = \u0026#34;我是不是你最疼爱的人\u0026#34; }); } } } 最终效果 # 通过上述代码，程序成功向指定用户（显示名称为“Thu Thuỷ”）发送了消息“我是不是你最疼爱的人”。效果截图如下：\n注意事项 # 合规性：本项目仅用于学习和研究，请确保遵守Zalo的服务条款，避免任何违规操作。 环境配置：确保Node.js服务器已正确运行 扩展性：当前功能较为简单，可根据需求扩展更多功能，如批量消息发送、消息定时发送等。 总结 # 本指南提供了一个简单的Zalo机器人实现方案，通过Node.js服务器和C#客户端的配合，实现了获取好友列表和发送消息的功能。希望对有兴趣开发Zalo机器人的开发者有所帮助！\n","date":"22 八月 2025","externalUrl":null,"permalink":"/article/zalo%E5%BC%80%E5%8F%91%E7%AE%80%E6%98%93%E6%9C%BA%E5%99%A8%E4%BA%BA/","section":"Articles","summary":"","title":"Zalo开发简易机器人","type":"article"},{"content":"","date":"22 八月 2025","externalUrl":null,"permalink":"/categories/%E9%80%86%E5%90%91/","section":"Categories","summary":"","title":"逆向","type":"categories"},{"content":"","date":"22 八月 2025","externalUrl":null,"permalink":"/tags/lol/","section":"Tags","summary":"","title":"LOL","type":"tags"},{"content":"声明：本文仅用于教育和研究目的。逆向工程可能违反RiotGames的服务条款，切勿用于作弊或其他违规行为。\n步骤1：使用Cheat Engine扫描动态地址 # 我们以英雄的生命值（HP）为例，通过Cheat Engine定位动态地址。启动LoL，进入练习模式，选择一名英雄（如Ezreal）。\n打开Cheat Engine，附加到League of Legends.exe进程。 在游戏中查看英雄当前HP（例如600）。在CE中： 设置扫描类型为“Exact Value”，值类型为“Float”。 输入600，点击“First Scan”。 让英雄受到伤害（例如HP降至550），在CE中： 切换扫描类型为“Decreased Value”。 点击“Next Scan”。 重复掉血和扫描，直到结果缩减到少数地址（通常4-5个）。选择与HP变化一致的地址（例如0x7FF123456789）。 添加地址到列表，验证其随HP变化。 以下是自动化扫描的CE Lua脚本示例：\nlocal process = getOpenedProcessID() if process == 0 then print(\u0026#34;Please attach to League of Legends process.\u0026#34;) return end local hpValue = 600.0 local scanType = stExactValue local valueType = vtSingle -- Initial scan local memScan = createMemScan() memScan.firstScan(scanType, valueType, 0, nil, tostring(hpValue), \u0026#34;\u0026#34;, 0x40000000, 0x7FFFFFFFFFFFFFFF, \u0026#34;+W-C\u0026#34;, fsmNotAligned, \u0026#34;\u0026#34;, true, false, false, false) memScan.waitTillDone() local foundList = createFoundList(memScan) foundList.initialize() -- Next scan after HP decrease hpValue = 550.0 memScan.nextScan(soDecreasedValue, true, true, false, nil) memScan.waitTillDone() foundList.update() -- Output top 5 results for i=0, math.min(5, foundList.Count-1) do print(string.format(\u0026#34;Address: 0x%X, Value: %f\u0026#34;, foundList.Address[i], foundList.Value[i])) end foundList.destroy() memScan.destroy() print(\u0026#34;Dynamic addresses identified. Proceed to pointer scanning.\u0026#34;) 运行脚本后，CE会返回动态地址列表。右键目标地址，选择“Find what writes to this address”设置断点，记录写入指令。\n步骤2：使用x64dbg寻找静态指针链 # 动态地址在游戏重启后失效，因此需通过x64dbg找到静态基址和偏移量。\n打开x64dbg，附加到League of Legends.exe进程。 在CE中找到的写入指令（例如movss xmm0, [rax+0x123]）对应的地址，在x64dbg的CPU视图中定位。 设置断点：使用bp \u0026lt;address\u0026gt;在写入指令处设置断点。触发游戏内HP变化（例如掉血），断点命中后检查寄存器（如RAX）。 追踪指针链：使用“Follow in Dump”分析多级指针。通常，人物数据存储在对象管理器中，基址可能为[League.dll + static_offset] + offsets。通过多次测试，记录稳定指针链，例如[[League.dll + 0x1A2B3C] + 0x100] + 0x20] + 0xA8。 以下是x64dbg中的典型汇编代码：\n; Example x64dbg disassembly for HP write 00007FF712345678: mov rax, [League.dll + 0x1A2B3C] ; Static base 00007FF71234567F: add rax, 0x100 ; First offset 00007FF712345684: mov rcx, [rax + 0x20] ; Second offset 00007FF712345689: cmp rcx, 0 00007FF71234568D: je short 00007FF7123456A0 00007FF71234568F: movss xmm0, dword ptr [rcx + 0xA8] ; HP offset 00007FF712345694: subss xmm0, xmm1 ; Apply damage 00007FF712345698: movss dword ptr [rcx + 0xA8], xmm0 ; Update HP 00007FF71234569D: ret 00007FF7123456A0: nop 以下是x64dbg Python脚本，用于解析指针链：\nimport x64dbgpy.plugin def resolve_pointer_chain(base, offsets): addr = x64dbgpy.plugin.remote_GetModuleBase(\u0026#34;League.dll\u0026#34;) + base for offset in offsets: addr = x64dbgpy.plugin.memory_ReadPtr(addr) if addr == 0: print(\u0026#34;Null pointer detected. Check offsets.\u0026#34;) return 0 addr += offset return addr base_offset = 0x1A2B3C offsets = [0x100, 0x20, 0xA8] hp_addr = resolve_pointer_chain(base_offset, offsets) if hp_addr != 0: hp_value = x64dbgpy.plugin.memory_ReadFloat(hp_addr) print(f\u0026#34;HP at 0x{hp_addr:X}: {hp_value}\u0026#34;) else: print(\u0026#34;Failed to resolve pointer chain.\u0026#34;) 运行脚本，验证指针链在多次游戏重启后是否稳定。\n步骤3：扩展分析其他数据 # HP基址只是起点。其他数据（如位置坐标X,Y,Z，技能等级）可通过类似方法获取：\n位置坐标：通常为浮点向量，偏移可能在+0x1C0附近。重复CE扫描，搜索X坐标（例如召唤师峡谷的坐标值）。 技能等级：为整数，扫描1（初始技能等级），升级技能后扫描“Increased Value”。 结构剖析：使用CE的“Dissect Data/Structures”功能，分析对象结构，记录偏移。 注意事项 # 反作弊：LoL的反作弊系统（如Vanguard）可能检测内存操作。测试时使用练习模式，必要时研究绕过方法（合法范围内）。 偏移变化：游戏更新可能改变偏移量，定期验证指针链。 调试：若地址失效，检查模块基址（League.dll）或使用x64dbg的调用栈分析解密函数。 总结 # 通过Cheat Engine扫描动态地址，结合x64dbg逆向静态指针链，你可以成功获取LoL中人物数据的基址，例如HP（[[League.dll + 0x1A2B3C] + 0x100] + 0x20] + 0xA8）。此方法适用于位置、技能等其他数据，核心是耐心扫描和验证。\n继续探索内存的奥秘，祝你逆向成功！\n","date":"22 八月 2025","externalUrl":null,"permalink":"/article/lol%E8%8E%B7%E5%8F%96%E4%BA%BA%E7%89%A9%E6%95%B0%E6%8D%AE%E5%9F%BA%E5%9D%80/","section":"Articles","summary":"","title":"Lol获取人物数据基址","type":"article"},{"content":"2001年出生\n一个平凡的数字游民\n喜欢在不健康的场所消磨时间\n喜欢骑着电车追逐黄昏\n沉迷于自己的世界，日渐消瘦\n","date":"21 八月 2025","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"关于","type":"page"},{"content":"","date":"21 八月 2025","externalUrl":null,"permalink":"/tags/%E5%85%B3%E4%BA%8E/","section":"Tags","summary":"","title":"关于","type":"tags"},{"content":"","date":"21 八月 2025","externalUrl":null,"permalink":"/categories/%E7%82%B8%E4%B8%B8%E5%AE%9D%E8%B4%9D/","section":"Categories","summary":"","title":"炸丸宝贝","type":"categories"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]